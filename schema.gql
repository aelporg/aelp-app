# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateUser {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input CountryCreateNestedOneWithoutUsersInput {
  connect: CountryWhereUniqueInput
  connectOrCreate: CountryCreateOrConnectWithoutUsersInput
  create: CountryCreateWithoutUsersInput
}

input CountryCreateOrConnectWithoutUsersInput {
  create: CountryCreateWithoutUsersInput!
  where: CountryWhereUniqueInput!
}

input CountryCreateWithoutUsersInput {
  countryCode: String!
  countryName: String!
  createdAt: Timestamp
  flagImageUrl: String!
  id: String
  updatedAt: Timestamp
}

input CountryOrderByWithRelationInput {
  countryCode: SortOrder
  countryName: SortOrder
  createdAt: SortOrder
  flagImageUrl: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  users: UserOrderByRelationAggregateInput
}

input CountryRelationFilter {
  is: CountryWhereInput
  isNot: CountryWhereInput
}

input CountryUpdateOneRequiredWithoutUsersInput {
  connect: CountryWhereUniqueInput
  connectOrCreate: CountryCreateOrConnectWithoutUsersInput
  create: CountryCreateWithoutUsersInput
  update: CountryUpdateWithoutUsersInput
  upsert: CountryUpsertWithoutUsersInput
}

input CountryUpdateWithoutUsersInput {
  countryCode: StringFieldUpdateOperationsInput
  countryName: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  flagImageUrl: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CountryUpsertWithoutUsersInput {
  create: CountryCreateWithoutUsersInput!
  update: CountryUpdateWithoutUsersInput!
}

input CountryWhereInput {
  AND: [CountryWhereInput!]
  NOT: [CountryWhereInput!]
  OR: [CountryWhereInput!]
  countryCode: StringFilter
  countryName: StringFilter
  createdAt: DateTimeFilter
  flagImageUrl: StringFilter
  id: StringFilter
  updatedAt: DateTimeFilter
  users: UserListRelationFilter
}

input CountryWhereUniqueInput {
  countryCode: String
  countryName: String
  id: String
}

input DateTimeFieldUpdateOperationsInput {
  set: Timestamp
}

input DateTimeFilter {
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeFilter
  notIn: [Timestamp!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeWithAggregatesFilter
  notIn: [Timestamp!]
}

input EnumRoleFieldUpdateOperationsInput {
  set: Role
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input EnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input LinkedAccountCreateManyUserInput {
  createdAt: Timestamp
  id: String
  providerId: String!
  updatedAt: Timestamp
}

input LinkedAccountCreateManyUserInputEnvelope {
  data: [LinkedAccountCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input LinkedAccountCreateNestedManyWithoutUserInput {
  connect: [LinkedAccountWhereUniqueInput!]
  connectOrCreate: [LinkedAccountCreateOrConnectWithoutUserInput!]
  create: [LinkedAccountCreateWithoutUserInput!]
  createMany: LinkedAccountCreateManyUserInputEnvelope
}

input LinkedAccountCreateOrConnectWithoutUserInput {
  create: LinkedAccountCreateWithoutUserInput!
  where: LinkedAccountWhereUniqueInput!
}

input LinkedAccountCreateWithoutUserInput {
  createdAt: Timestamp
  id: String
  provider: ProviderCreateNestedOneWithoutLinkedAccountsInput!
  updatedAt: Timestamp
}

input LinkedAccountListRelationFilter {
  every: LinkedAccountWhereInput
  none: LinkedAccountWhereInput
  some: LinkedAccountWhereInput
}

input LinkedAccountOrderByRelationAggregateInput {
  _count: SortOrder
}

input LinkedAccountScalarWhereInput {
  AND: [LinkedAccountScalarWhereInput!]
  NOT: [LinkedAccountScalarWhereInput!]
  OR: [LinkedAccountScalarWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  providerId: StringFilter
  updatedAt: DateTimeFilter
  userId: StringFilter
}

input LinkedAccountUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LinkedAccountUpdateManyWithWhereWithoutUserInput {
  data: LinkedAccountUpdateManyMutationInput!
  where: LinkedAccountScalarWhereInput!
}

input LinkedAccountUpdateManyWithoutUserInput {
  connect: [LinkedAccountWhereUniqueInput!]
  connectOrCreate: [LinkedAccountCreateOrConnectWithoutUserInput!]
  create: [LinkedAccountCreateWithoutUserInput!]
  createMany: LinkedAccountCreateManyUserInputEnvelope
  delete: [LinkedAccountWhereUniqueInput!]
  deleteMany: [LinkedAccountScalarWhereInput!]
  disconnect: [LinkedAccountWhereUniqueInput!]
  set: [LinkedAccountWhereUniqueInput!]
  update: [LinkedAccountUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [LinkedAccountUpdateManyWithWhereWithoutUserInput!]
  upsert: [LinkedAccountUpsertWithWhereUniqueWithoutUserInput!]
}

input LinkedAccountUpdateWithWhereUniqueWithoutUserInput {
  data: LinkedAccountUpdateWithoutUserInput!
  where: LinkedAccountWhereUniqueInput!
}

input LinkedAccountUpdateWithoutUserInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  provider: ProviderUpdateOneRequiredWithoutLinkedAccountsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LinkedAccountUpsertWithWhereUniqueWithoutUserInput {
  create: LinkedAccountCreateWithoutUserInput!
  update: LinkedAccountUpdateWithoutUserInput!
  where: LinkedAccountWhereUniqueInput!
}

input LinkedAccountWhereInput {
  AND: [LinkedAccountWhereInput!]
  NOT: [LinkedAccountWhereInput!]
  OR: [LinkedAccountWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  provider: ProviderRelationFilter
  providerId: StringFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: StringFilter
}

input LinkedAccountWhereUniqueInput {
  id: String
}

type Mutation {
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createUser(data: UserCreateInput!): User!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteUser(where: UserWhereUniqueInput!): User
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeFilter
  notIn: [Timestamp!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeWithAggregatesFilter
  notIn: [Timestamp!]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input NestedEnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input ProviderCreateNestedOneWithoutLinkedAccountsInput {
  connect: ProviderWhereUniqueInput
  connectOrCreate: ProviderCreateOrConnectWithoutLinkedAccountsInput
  create: ProviderCreateWithoutLinkedAccountsInput
}

input ProviderCreateOrConnectWithoutLinkedAccountsInput {
  create: ProviderCreateWithoutLinkedAccountsInput!
  where: ProviderWhereUniqueInput!
}

input ProviderCreateWithoutLinkedAccountsInput {
  createdAt: Timestamp
  id: String
  name: String!
  updatedAt: Timestamp
}

input ProviderRelationFilter {
  is: ProviderWhereInput
  isNot: ProviderWhereInput
}

input ProviderUpdateOneRequiredWithoutLinkedAccountsInput {
  connect: ProviderWhereUniqueInput
  connectOrCreate: ProviderCreateOrConnectWithoutLinkedAccountsInput
  create: ProviderCreateWithoutLinkedAccountsInput
  update: ProviderUpdateWithoutLinkedAccountsInput
  upsert: ProviderUpsertWithoutLinkedAccountsInput
}

input ProviderUpdateWithoutLinkedAccountsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProviderUpsertWithoutLinkedAccountsInput {
  create: ProviderCreateWithoutLinkedAccountsInput!
  update: ProviderUpdateWithoutLinkedAccountsInput!
}

input ProviderWhereInput {
  AND: [ProviderWhereInput!]
  NOT: [ProviderWhereInput!]
  OR: [ProviderWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  linkedAccounts: LinkedAccountListRelationFilter
  name: StringFilter
  updatedAt: DateTimeFilter
}

input ProviderWhereUniqueInput {
  id: String
  name: String
}

type Query {
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

enum Role {
  ADMIN
  USER
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

"""
The javascript `Date` as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar Timestamp

type User {
  _count: UserCount
  countryId: String!
  createdAt: Timestamp!
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  role: Role!
  updatedAt: Timestamp!
  userName: String!
}

type UserCount {
  linkedAccounts: Int!
  refreshTokens: Int!
}

type UserCountAggregate {
  _all: Int!
  countryId: Int!
  createdAt: Int!
  email: Int!
  firstName: Int!
  id: Int!
  lastName: Int!
  password: Int!
  role: Int!
  updatedAt: Int!
  userName: Int!
}

input UserCountOrderByAggregateInput {
  countryId: SortOrder
  createdAt: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  role: SortOrder
  updatedAt: SortOrder
  userName: SortOrder
}

input UserCreateInput {
  country: CountryCreateNestedOneWithoutUsersInput!
  createdAt: Timestamp
  email: String!
  firstName: String!
  id: String
  lastName: String!
  linkedAccounts: LinkedAccountCreateNestedManyWithoutUserInput
  password: String!
  refreshTokens: UserRefreshTokenCreateNestedManyWithoutUserInput
  role: Role
  updatedAt: Timestamp
  userName: String!
}

input UserCreateManyInput {
  countryId: String!
  createdAt: Timestamp
  email: String!
  firstName: String!
  id: String
  lastName: String!
  password: String!
  role: Role
  updatedAt: Timestamp
  userName: String!
}

type UserGroupBy {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  countryId: String!
  createdAt: Timestamp!
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  password: String!
  role: Role!
  updatedAt: Timestamp!
  userName: String!
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

type UserMaxAggregate {
  countryId: String
  createdAt: Timestamp
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  role: Role
  updatedAt: Timestamp
  userName: String
}

input UserMaxOrderByAggregateInput {
  countryId: SortOrder
  createdAt: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  role: SortOrder
  updatedAt: SortOrder
  userName: SortOrder
}

type UserMinAggregate {
  countryId: String
  createdAt: Timestamp
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  role: Role
  updatedAt: Timestamp
  userName: String
}

input UserMinOrderByAggregateInput {
  countryId: SortOrder
  createdAt: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  role: SortOrder
  updatedAt: SortOrder
  userName: SortOrder
}

input UserOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserOrderByWithAggregationInput {
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  countryId: SortOrder
  createdAt: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  role: SortOrder
  updatedAt: SortOrder
  userName: SortOrder
}

input UserOrderByWithRelationInput {
  country: CountryOrderByWithRelationInput
  countryId: SortOrder
  createdAt: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  linkedAccounts: LinkedAccountOrderByRelationAggregateInput
  password: SortOrder
  refreshTokens: UserRefreshTokenOrderByRelationAggregateInput
  role: SortOrder
  updatedAt: SortOrder
  userName: SortOrder
}

input UserRefreshTokenCreateManyUserInput {
  createdAt: Timestamp
  id: String
  invalid: Boolean
  token: String!
  updatedAt: Timestamp
}

input UserRefreshTokenCreateManyUserInputEnvelope {
  data: [UserRefreshTokenCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input UserRefreshTokenCreateNestedManyWithoutUserInput {
  connect: [UserRefreshTokenWhereUniqueInput!]
  connectOrCreate: [UserRefreshTokenCreateOrConnectWithoutUserInput!]
  create: [UserRefreshTokenCreateWithoutUserInput!]
  createMany: UserRefreshTokenCreateManyUserInputEnvelope
}

input UserRefreshTokenCreateOrConnectWithoutUserInput {
  create: UserRefreshTokenCreateWithoutUserInput!
  where: UserRefreshTokenWhereUniqueInput!
}

input UserRefreshTokenCreateWithoutUserInput {
  createdAt: Timestamp
  id: String
  invalid: Boolean
  token: String!
  updatedAt: Timestamp
}

input UserRefreshTokenListRelationFilter {
  every: UserRefreshTokenWhereInput
  none: UserRefreshTokenWhereInput
  some: UserRefreshTokenWhereInput
}

input UserRefreshTokenOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserRefreshTokenScalarWhereInput {
  AND: [UserRefreshTokenScalarWhereInput!]
  NOT: [UserRefreshTokenScalarWhereInput!]
  OR: [UserRefreshTokenScalarWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  invalid: BoolFilter
  token: StringFilter
  updatedAt: DateTimeFilter
  userId: StringFilter
}

input UserRefreshTokenUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  invalid: BoolFieldUpdateOperationsInput
  token: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserRefreshTokenUpdateManyWithWhereWithoutUserInput {
  data: UserRefreshTokenUpdateManyMutationInput!
  where: UserRefreshTokenScalarWhereInput!
}

input UserRefreshTokenUpdateManyWithoutUserInput {
  connect: [UserRefreshTokenWhereUniqueInput!]
  connectOrCreate: [UserRefreshTokenCreateOrConnectWithoutUserInput!]
  create: [UserRefreshTokenCreateWithoutUserInput!]
  createMany: UserRefreshTokenCreateManyUserInputEnvelope
  delete: [UserRefreshTokenWhereUniqueInput!]
  deleteMany: [UserRefreshTokenScalarWhereInput!]
  disconnect: [UserRefreshTokenWhereUniqueInput!]
  set: [UserRefreshTokenWhereUniqueInput!]
  update: [UserRefreshTokenUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [UserRefreshTokenUpdateManyWithWhereWithoutUserInput!]
  upsert: [UserRefreshTokenUpsertWithWhereUniqueWithoutUserInput!]
}

input UserRefreshTokenUpdateWithWhereUniqueWithoutUserInput {
  data: UserRefreshTokenUpdateWithoutUserInput!
  where: UserRefreshTokenWhereUniqueInput!
}

input UserRefreshTokenUpdateWithoutUserInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  invalid: BoolFieldUpdateOperationsInput
  token: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserRefreshTokenUpsertWithWhereUniqueWithoutUserInput {
  create: UserRefreshTokenCreateWithoutUserInput!
  update: UserRefreshTokenUpdateWithoutUserInput!
  where: UserRefreshTokenWhereUniqueInput!
}

input UserRefreshTokenWhereInput {
  AND: [UserRefreshTokenWhereInput!]
  NOT: [UserRefreshTokenWhereInput!]
  OR: [UserRefreshTokenWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  invalid: BoolFilter
  token: StringFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: StringFilter
}

input UserRefreshTokenWhereUniqueInput {
  id: String
  token: String
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  countryId
  createdAt
  email
  firstName
  id
  lastName
  password
  role
  updatedAt
  userName
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  countryId: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  password: StringWithAggregatesFilter
  role: EnumRoleWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userName: StringWithAggregatesFilter
}

input UserUpdateInput {
  country: CountryUpdateOneRequiredWithoutUsersInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  linkedAccounts: LinkedAccountUpdateManyWithoutUserInput
  password: StringFieldUpdateOperationsInput
  refreshTokens: UserRefreshTokenUpdateManyWithoutUserInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  userName: StringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  userName: StringFieldUpdateOperationsInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  country: CountryRelationFilter
  countryId: StringFilter
  createdAt: DateTimeFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  linkedAccounts: LinkedAccountListRelationFilter
  password: StringFilter
  refreshTokens: UserRefreshTokenListRelationFilter
  role: EnumRoleFilter
  updatedAt: DateTimeFilter
  userName: StringFilter
}

input UserWhereUniqueInput {
  id: String
  userName: String
}
